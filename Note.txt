https://styled-components.com/
https://stylis.js.org/
https://medium.com/building-crowdriff/styled-components-to-use-or-not-to-use-a6bb4a7ffc21
https://mxstbr.blog/2016/11/styled-components-magic-explained/

Need to read:
https://github.com/styled-components/jest-styled-components         <<< Need to rea this to see if you can do testing.
https://styled-components.com/docs/api#helpers                      <<< About create GlobalStyle

https://github.com/Annie-Huang/my-styled-components-tutorial
######################################################################################
Up to: https://styled-components.com/docs/advanced#referring-to-other-components


Learning from version 5:

C:\react>npx create-react-app my-styled-components-tutorial
C:\react\my-styled-components-tutorial>npm install --save styled-components

C:\react\my-styled-components-tutorial>npm install --save-dev babel-plugin-styled-components
(Read notes in C:\react\my-styled-components-tutorial\NoteBabelWebpack.txt)


=======================================================================================


1.
Adapting based on props:
    background: ${(props) => (props.primary ? 'palevioletred' : 'white')};

2.
Extending Styles
    export const TomatoButton = styled(Button2)`...`

3.
"as" polymorphic prop (introduced in v4): Will change the element name
    <Button3 as='a' href='/'>Link with Button styles</Button3>
    change to:
    <a href="/" class="sc-eCssSg bpkTHM">Link with Button styles</a>

4.
"as" polymorphic prop works with custom components too!
    const ReversedButton = props => <Button {...props} children={props.children.split('').reverse()} />
    <Button4 as={ReversedButton}>
      Custom Button with Normal Button styles
    </Button4>

5.
The styled method works perfectly on all of your own or any third-party component
as long as they attach the passed className prop to a DOM element.
    <Link>Unstyled, boring Link</Link>
    <StyledLink>Styled, exciting Link</StyledLink>
    // This could be react-router-dom's Link for example
    export const Link = ({ className, children }) => (
      <a className={className}>{children}</a>
    );
    export const StyledLink = styled(Link)`
      color: palevioletred;
      font-weight: bold;
    `;

6.
Passed props: styled-components filters non-standard attributes and not to pass to DOM:
e.g.inputColor prop is not passed to the DOM, but type and defaultValue are.
    export const Input = styled.input`...`
    <Input defaultValue="@geelen" type="text" inputColor="rebeccapurple" />
    This will translate to (in devtool)
    <input type="text" class="sc-crrsfI itEbJL" value="@geelen">

7.
Define Styled Components outside of the render method to avoid recreation on every single render pass.
Defining a styled component within the render method will thwart caching and drastically slow down rendering speed, and should be avoided.
    const StyledWrapper = styled.div`
      /* ... */
    `
    const Wrapper = ({ message }) => {
      return <StyledWrapper>{message}</StyledWrapper>
    }

8.
Pseudoelements, pseudoselectors, and nesting:
    Check Thing.js. Interestingly I didn't know this before:
    <div className='something-else'>
      <Thing>Splendid.</Thing>
    </div>
    export const Thing = styled.div.attrs((/* props */) => ({ tabIndex: 0 }))`
      .something-else & {
          border: 1px solid; // Do border style on <Thing> element that is inside another element labeled ".something-else"
      }
    `

9.
If you put selectors in without the ampersand (the '&' sign), they will refer to children of the component.
    <Thing2>
      <label htmlFor='foo-button' className='something'>
        Mystery button
      </label>
      ...
    </Thing2>
    export const Thing2 = styled.div`
      .something {
        border: 1px solid; // an element labeled ".something" inside <Thing>
        display: block;
      }
    `;

10.
(point 22 is also about specificity)
The ampersand (the '&' sign) can be used to increase the specificity of rules on the component; this can be useful if you are
dealing with a mixed styled-components and vanilla CSS environment where there might be conflicting styles:
    <GlobalStyle />
    <Thing3>
      I'm blue, da ba dee da ba daa
    </Thing3>
    const Thing3 = styled.div`
      && {
        color: blue;        <<< Higher specificity.
      }
    `
    export const GlobalStyle = createGlobalStyle`  // createGlobalStyle is available after v4, web only.
      div${Thing3} {
        color: red;
      }
    `;


11.
createGlobalStyle: things like CSS resets or base stylesheets can be applied.
https://styled-components.com/docs/api#helpers
    import { createGlobalStyle, ThemeProvider } from 'styled-components/macro'
    const GlobalStyle = createGlobalStyle`
      body {
        color: ${props => (props.whiteColor ? 'white' : 'black')};
        font-family: ${props => props.theme.fontFamily};
      }
    `
    // later in your app
    <ThemeProvider theme={{ fontFamily: 'Helvetica Neue' }}>
      <React.Fragment>
        <Navigation /> {/* example of other top-level stuff */}
        <GlobalStyle whiteColor />
      </React.Fragment>
    </ThemeProvider>

12.
.attrs constructor: It allows you to attach additional props (or "attributes") to a component.
    <Input2 placeholder='A small text input' />
    <Input2 placeholder='A bigger text input' size='2em' />
    export const Input2 = styled.input.attrs((props) => ({      <<< Prop Factory
      type: 'text',
      size: props.size || '1em',
    }))`
      border: 2px solid palevioletred;
      /* here we use the dynamically computed prop */
      margin: ${(props) => props.size};
      padding: ${(props) => props.size};
    `;

13.
Overriding .attrs
Each wrapper to override nested uses of .attrs, similarly to how css properties defined later in a stylesheet override previous declarations.
    <Input2 placeholder='A bigger text input' size='2em' />
    <PasswordInput2 placeholder='A bigger password input' size='2em' />
    export const PasswordInput2 = styled(Input2).attrs({        <<< Prop Value
      type: 'password',
    })`
      // similarly, border will override Input's border
      border: 2px solid aqua;
    `;

14.
Animations: keyframe
    const rotate = keyframes`
      from {transform: rotate(0deg);}
      to {transform: rotate(360deg);}
    `;
    export const Rotate = styled.div`
      animation: ${rotate} 2s linear infinite;
    `;
Or you can do it inside the styled-component:
    const SpinnerContainer = styled.div`
      svg {
        animation: rotation 2s infinite linear;
      }
      @keyframes rotation {
        from {transform: rotate(0deg);}
        to {transform: rotate(359deg);}
      }
    `;

15.
Keyframes are lazily injected when they're used, which is how they can be code-splitted, so you have to use the css helper for shared style fragments:
    const styles2 = css`    <<< Need to add css here.
      animation: ${rotate} 2s linear infinite;
    `;

16.
Theme. <ThemeProvider> wrapper component
In the render tree all styled-components will have access to the provided theme, even when they are multiple levels deep.
    export const Button5 = styled.button`
      color: ${(props) => props.theme.main};
      border: 2px solid ${(props) => props.theme.main};
    `;
    Button5.defaultProps = {
      theme: {
        main: 'palevioletred',
      },
    };
    export const theme = {
      main: 'mediumseagreen',
    };
      <Container>
        <Button5>Normal</Button5>

        <ThemeProvider theme={theme}>
          <Button5>Themed</Button5>
        </ThemeProvider>
      </Container>

17.
withTheme
    import { withTheme } from 'styled-components/macro';
    class MyComponent extends React.Component {
      render() {
        console.log('Current theme: ', this.props.theme);
        // ...
      }
    }
    export default withTheme(MyComponent);

18.
ThemeContext
    import { useContext } from 'react';
    import { ThemeContext } from 'styled-components/macro';
    const MyComponent = () => {
      const themeContext = useContext(ThemeContext);
      console.log('Current theme: ', themeContext);
      // ...
    }

19.
The theme prop
    render(
      <div>
        <Button theme={{ main: "royalblue" }}>Ad hoc theme</Button>
        <ThemeProvider theme={theme}>
          <div>
            <Button>Themed</Button>
            <Button theme={{ main: "darkorange" }}>Overridden</Button>
          </div>
        </ThemeProvider>
      </div>
    );

20.
Refs. Passing a ref prop to a styled component will give you
the underlying DOM node (if targeting a basic element, e.g. styled.div)
a React component instance (if targeting a custom component e.g. extended from React.Component)
    const input3Ref = React.useRef(null);
    <Input3
      ref={input3Ref}
      placeholder='Hover to focus!'
      onMouseEnter={() => {
        input3Ref.current.focus();
      }}
    />

21.
Existing CSS.
make sure your component attaches the passed-in className to a DOM node:
    class MyComponent extends React.Component {
      render() {
        // Attach the passed-in className to the DOM node
        return <div className={this.props.className} />
      }
    }
    class MyComponent extends React.Component {
      render() {
        // Attach the passed-in className to the DOM node
        return <div className={`some-global-class ${this.props.className}`} />
      }
    }

22.
Issues with specificity
(point 10 is also about specificity)
styled-components injects its styles during runtime at the end of the <head> by default.    <<< !!! important concept.
Thus its styles win over other single classname selectors.
    // MyComponent.js
    const MyComponent = styled.div`background-color: green;`;
    // my-component.css
    .red-bg {
      background-color: red;
    }
    // For some reason this component still has a green background,
    // even though you're trying to override it with the "red-bg" class!
    <MyComponent className="red-bg" />
    --------------------------
    So Solution is:
    /* my-component.css */
    .red-bg.red-bg {
      background-color: red;
    }
Or you can use plugin like: babel-plugin-styled-components-css-namespace
which can do:
    [
      "@quickbaseoss/babel-plugin-styled-components-css-namespace",
      {"cssNamespace": "&&&"}               <<< (the default behavior is x2 {"cssNamespace": "&&"}).
    ],
    /* output */
    .c0.c0.c0 {
      background-color: blue;
    }

23.
Tagged Template Literals
    const Title = styled.h1`
      /* Text centering won't break if props.upsidedown is falsy */
      ${props.upsidedown && 'transform: rotate(180deg);'}       <<< If there is not variable, you can just use ''
      text-align: center;
    `;
    ${props =>
    props.step.subStepOf &&
    `                               <<< have to use `` because we evaluation another ${} again inside.
      &.inProgress {
        span {
          color: ${theme.colors.blueInfoDark};
        }
      }
    `}


24.
Referring to other components (Referring to other already used style-component component)
Whenever a component is created or wrapped by the styled() factory function, it is also assigned a stable CSS class for use in targeting.
This allows for extremely powerful composition patterns without having to fuss around with naming and avoiding selector collisions.
    export const Link2 = styled.a`
      ...
    `;
    export const Icon2 = styled.svg`
      ...
      ${Link2}:hover & {        <<< & means whenever hover on <a> element (Link2), apply the style in <svg> element (Icons2)
        fill: rebeccapurple;
      }
    `;
    <Link2 href='#'>
      <Icon2 viewBox='0 0 20 20'>
        <path d='M10 15h8c1 0 2-1 2-2V3c0-1-1-2-2-2H2C1 1 0 2 0 3v10c0 1 1 2 2 2h4v4l4-4zM5 7h2v2H5V7zm4 0h2v2H9V7zm4 0h2v2h-2V7z' />
      </Icon2>
      <Label2>Hovering my parent changes my style!</Label2>
    </Link2>

Other example like for datagrid:
    ${Cell}, ${FirstCell} {
      --list-row-bg-color: var(--list-row-bg-disabled-color);
    }
    -------------
    &:hover,
    &:focus-within {
      ${FirstCell} , td:not(:first-child) {
        --list-row-bg-color: var(--list-row-bg-focus-color);
      }
    }
    -------------
    &:focus-within ${FirstCell} {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }




A.
css: A helper function to generate CSS from a template literal with interpolations
If you're interpolating a string you do not need to use this, only if you're interpolating a function.
e.g.
const complexMixin = css`
  color: ${props => (props.whiteColor ? 'white' : 'black')};
`

When to use css`` and when no need to use it:
  ${props =>
    !props.disabled &&
    ` &:hover label{
        background-color: ${theme.colors.blueInfoLight};
        transition: background-color 0.1s ease-out;
        border-radius: ${theme.borders.borderRadiusSmall}px 0 0 ${theme.borders.borderRadiusSmall}px;
  }`}
  ${props =>
    props.vertical &&
    css`                                <<< I don't think this need to have...
      flex-direction: column;
      line-height: 20px;
    `}
  ${props =>
    !props.hasInlineLabel &&
    css`                                <<< I don't think this need to have...
      &:hover:not(:focus) {
        border-radius: ${theme.borders.borderRadiusSmall}px;
      }
    `}















